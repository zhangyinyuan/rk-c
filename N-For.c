// 标准输入输出流
#include <math.h>
#include <stdio.h>

// 定义1个N x N的棋盘
// 这是一个宏定义，属于C语言的预处理指令
// 代码中所有出现 N 的地方都会被替换为 4
// 不可修改,调试的时候,看不到N(替换后符号消失)
// 定义1个标识符, 常量 4. 表示4个皇后
#define N 10

// 定义了一个名为 q 的整型数组
// 由于N=4,所以数组的大小为5
// 存储皇后的列号
int q[N + 1];

// 检查第j个皇后的位置是否合法
// 由于不同的皇后不会放在同一行,所以不用判断行
// 只需要判断两个皇后不在同一列并且不在一条斜线上, 即认为当前皇后的位置合法;反之不合法
// j表示当前正在摆放的第j个皇后
int check(int j) {
    // 如果当前皇后和它之前的每一个皇后相比,
    // 在同一行或者同一个斜线上,认为位置不合法,否则对比完它之前的所有皇后之后,位置都是合法的, 则认为位置合法
    for (int i = 1; i < j; ++i) {
        if (q[i] == q[j] || abs(i - j) == abs(q[i] - q[j])) {
            // 表示在同一列或者同一个斜线上.位置不合法
            return 0;
        }
    }
    return 1;
}

// 求解N皇后的方案
void queue() {
    // 从1开始,q[i]表示第i个皇后
    for (int i = 1; i <= N; ++i) {
        q[i] = 0; // 把每个皇后的列都定义为0,表示全都没有放入棋盘.反之>0,比如q[i] = 1,表示第1个皇后放在了第一行的第一列
    }

    // 方案数
    int answer = 0;

    // 表示正在摆放第j个皇后
    int j = 1;
    // i <=N 表示要摆放N个皇后
    while (j >= 1) {
        // 表示将第j个皇后,向右移动1个位置.
        // 初始的时候,表示将第1个皇后从棋盘外(q[0]移动到第一行的第1列)
        q[j]++;

        while (q[j] <= N && !check(j)) {
            // 这里必须要加上=N,如果不加.就会少一个越界的场景.导致由于越界后需要调整上一个皇后位置的场景丢失.最终导致数据错乱
            q[j] = q[j] + 1;
        }

        if (q[j] <= N) {
            if (j == N) { // 找到了N皇后的一组解
                answer++;
                printf("方案%d:  ", answer);
                for (int i = 1; i <= N; ++i) {
                    printf("%d,", q[i]);
                }
                printf("\n");
            } else {
                // 继续摆放下一个皇后的位置
                j++;
            }
        } else {
            // 越界,回溯
            q[j] = 0;
            j--;
        }
    }
}

int main(int argc, char const *argv[]) {
    queue();

    return 0;
}
